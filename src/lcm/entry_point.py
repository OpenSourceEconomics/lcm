from collections.abc import Callable
from functools import partial
from typing import Literal

import jax
import pandas as pd
from jax import Array

from lcm.conditional_continuation import (
    get_compute_conditional_continuation_policy,
    get_compute_conditional_continuation_value,
)
from lcm.discrete_problem import get_solve_discrete_problem_value
from lcm.input_processing import process_model
from lcm.interfaces import StateChoiceSpace, StateSpaceInfo
from lcm.logging import get_logger
from lcm.next_state import get_next_state_function
from lcm.simulation.simulate import simulate, solve_and_simulate
from lcm.solution.solve_brute import solve
from lcm.solution.state_choice_space import create_state_choice_space
from lcm.typing import DiscreteProblemValueSolverFunction, ParamsDict, Target
from lcm.user_model import Model
from lcm.utility_and_feasibility import (
    get_utility_and_feasibility_function,
)


def get_lcm_function(
    model: Model,
    *,
    targets: Literal["solve", "simulate", "solve_and_simulate"],
    debug_mode: bool = True,
    jit: bool = True,
) -> tuple[Callable[..., list[Array] | pd.DataFrame], ParamsDict]:
    """Entry point for users to get high level functions generated by lcm.

    Return the function to solve and/or simulate a model along with a template for the
    parameters.

    Advanced users might want to use lower level functions instead, but can read the
    source code of this function to see how the lower level components are meant to be
    used.

    Args:
        model: User model specification.
        targets: The requested function types. Currently only "solve", "simulate" and
            "solve_and_simulate" are supported.
        debug_mode: Whether to log debug messages.
        jit: Whether to jit the returned function.

    Returns:
        - A function that takes params (and possibly other arguments, such as initial
          states in the simulate case) and returns the requested targets.
        - A parameter dictionary where all parameter values are initialized to NaN.

    """
    # ==================================================================================
    # preparations
    # ==================================================================================
    if targets not in {"solve", "simulate", "solve_and_simulate"}:
        raise NotImplementedError

    internal_model = process_model(model)
    last_period = internal_model.n_periods - 1

    logger = get_logger(debug_mode=debug_mode)

    # ==================================================================================
    # Create continuous choice grids
    # ----------------------------------------------------------------------------------
    # For now they are the same in all periods but this can change.
    # ==================================================================================
    continuous_choices_names = internal_model.variable_info.query(
        "is_continuous & is_choice"
    ).index.tolist()
    _choice_grids = {n: internal_model.grids[n] for n in continuous_choices_names}
    continuous_choice_grids = {
        period: _choice_grids for period in range(internal_model.n_periods)
    }

    # ==================================================================================
    # Create model functions and state-choice-spaces
    # ==================================================================================
    state_choice_spaces: dict[int, StateChoiceSpace] = {}
    state_space_infos: dict[int, StateSpaceInfo] = {}
    compute_ccv_functions: dict[int, Callable[[Array, Array], Array]] = {}
    compute_ccp_functions: dict[int, Callable[..., tuple[Array, Array]]] = {}
    solve_discrete_problem_functions: dict[int, DiscreteProblemValueSolverFunction] = {}

    for period in reversed(range(internal_model.n_periods)):
        is_last_period = period == last_period

        state_choice_space, state_space_info = create_state_choice_space(
            model=internal_model,
            is_last_period=is_last_period,
        )

        if is_last_period:
            next_state_space_info = LastPeriodsNextStateSpaceInfo
        else:
            next_state_space_info = state_space_infos[period + 1]

        u_and_f = get_utility_and_feasibility_function(
            model=internal_model,
            next_state_space_info=next_state_space_info,
            period=period,
            is_last_period=is_last_period,
        )

        compute_ccv = get_compute_conditional_continuation_value(
            utility_and_feasibility=u_and_f,
            continuous_choice_variables=tuple(_choice_grids),
        )

        compute_ccp = get_compute_conditional_continuation_policy(
            utility_and_feasibility=u_and_f,
            continuous_choice_variables=tuple(_choice_grids),
        )

        solve_discrete_problem = get_solve_discrete_problem_value(
            random_utility_shock_type=internal_model.random_utility_shocks,
            variable_info=internal_model.variable_info,
            is_last_period=is_last_period,
        )

        state_choice_spaces[period] = state_choice_space
        state_space_infos[period] = state_space_info
        compute_ccv_functions[period] = compute_ccv
        compute_ccp_functions[period] = compute_ccp
        solve_discrete_problem_functions[period] = solve_discrete_problem

    # ==================================================================================
    # select requested solver and partial arguments into it
    # ==================================================================================
    _solve_model = partial(
        solve,
        state_choice_spaces=state_choice_spaces,
        continuous_choice_grids=continuous_choice_grids,
        compute_ccv_functions=compute_ccv_functions,
        emax_calculators=solve_discrete_problem_functions,
        logger=logger,
    )

    _next_state_simulate = get_next_state_function(
        model=internal_model, target=Target.SIMULATE
    )

    solve_model = jax.jit(_solve_model) if jit else _solve_model
    next_state_simulate = jax.jit(_next_state_simulate) if jit else _next_state_simulate

    simulate_model = partial(
        simulate,
        continuous_choice_grids=continuous_choice_grids,
        compute_ccv_policy_functions=compute_ccp_functions,
        model=internal_model,
        next_state=next_state_simulate,  # type: ignore[arg-type]
        logger=logger,
    )

    solve_and_simulate_model = partial(
        solve_and_simulate,
        continuous_choice_grids=continuous_choice_grids,
        compute_ccv_policy_functions=compute_ccp_functions,
        model=internal_model,
        next_state=next_state_simulate,  # type: ignore[arg-type]
        logger=logger,
        solve_model=solve_model,
    )

    target_func: Callable[..., list[Array] | pd.DataFrame]

    if targets == "solve":
        target_func = solve_model
    elif targets == "simulate":
        target_func = simulate_model
    elif targets == "solve_and_simulate":
        target_func = solve_and_simulate_model

    return target_func, internal_model.params


LastPeriodsNextStateSpaceInfo = StateSpaceInfo(
    states_names=(),
    discrete_states={},
    continuous_states={},
)
